iimport boto3
import time
from reportlab.lib.pagesizes import letter
from reportlab.pdfgen import canvas
from reportlab.platypus import Table

# Step 1: Start Textract Asynchronous Job for Large PDFs or Complex Documents
def start_textract_job(bucket_name, document_name):
    textract = boto3.client('textract')

    # Start document analysis (asynchronous)
    response = textract.start_document_analysis(
        DocumentLocation={
            'S3Object': {
                'Bucket': bucket_name,
                'Name': document_name
            }
        },
        FeatureTypes=['TABLES', 'FORMS']
    )

    job_id = response['JobId']
    return job_id


# Step 2: Check Job Status
def check_textract_job_status(job_id):
    textract = boto3.client('textract')
    while True:
        response = textract.get_document_analysis(JobId=job_id)
        status = response['JobStatus']
        if status == 'SUCCEEDED':
            return response
        elif status == 'FAILED':
            raise Exception(f"Textract job failed: {response}")
        time.sleep(5)


# Step 3: Extract Text and Tables After Job Completion
def extract_text_and_tables_from_s3_async(bucket_name, document_name):
    # Start Textract job
    job_id = start_textract_job(bucket_name, document_name)
    
    # Wait for job to complete and get result
    response = check_textract_job_status(job_id)

    # Extract relevant information (blocks)
    blocks = response['Blocks']
    
    # Lists to store extracted text and tables
    texts = []
    tables = []

    # Helper function to extract table data
    def extract_table_data(relationship_block, block_map):
        table_data = []
        for relationship in relationship_block['Relationships']:
            if relationship['Type'] == 'CHILD':
                for child_id in relationship['Ids']:
                    cell_block = block_map[child_id]
                    if cell_block['BlockType'] == 'CELL':
                        table_data.append(cell_block['Text'] if 'Text' in cell_block else "")
        return table_data

    # Map blocks by their block ID
    block_map = {block['Id']: block for block in blocks}

    # Iterate through blocks to get text and tables
    for block in blocks:
        if block['BlockType'] == 'LINE':
            texts.append(block['Text'])
        elif block['BlockType'] == 'TABLE':
            table_data = extract_table_data(block, block_map)
            tables.append(table_data)

    # Return extracted text and tables
    extracted_text = "\n".join(texts)
    return extracted_text, tables


# Step 4: Use Claude 3.5 to Generate New Content
def generate_new_content(extracted_text, tables):
    from langchain_community.bedrock import Bedrock

    # Initialize the Bedrock client
    client = boto3.client("bedrock-runtime")

    # Instantiate the Claude 3.5 model from Bedrock
    model = Bedrock(model_id="claude-3.5", client=client)

    # Prepare the prompt with the extracted text
    prompt = f"""
    Based on the following input structure, generate a new version of the content while preserving the format:

    [Text Content]
    {extracted_text}
    """

    # Add each table to the prompt
    for i, table in enumerate(tables):
        prompt += f"\n[Table {i + 1}]\n"
        table_content = "\n".join([str(cell) for cell in table])  # Formatting the table cells
        prompt += table_content if table_content else 'No table data'

    # Generate new content using Claude
    result = model.generate(prompt)
    return result


# Step 5: Rebuild the PDF with Tables and Text Using reportlab
def create_pdf(content, tables, output_file):
    c = canvas.Canvas(output_file, pagesize=letter)
    width, height = letter

    # Write text content to the PDF
    text = c.beginText(40, height - 40)
    text.textLines(content)
    c.drawText(text)

    # Draw tables on the PDF
    for i, table_data in enumerate(tables):
        if table_data:
            # Render a table, adjust position and size as needed
            table = Table([table_data], repeatRows=1)
            table.wrapOn(c, width, height)
            table.drawOn(c, 40, height - (200 + (i * 100)))  # Adjust positions accordingly

    # Save the PDF
    c.save()


# Step 6: Main function to process the PDF from S3 and create a new version
def process_pdf_from_s3(bucket_name, document_name, output_pdf):
    # Step 1: Extract text and tables from the input PDF stored in S3
    extracted_text, tables = extract_text_and_tables_from_s3_async(bucket_name, document_name)

    # Step 2: Generate new content based on extracted data
    new_content = generate_new_content(extracted_text, tables)

    # Step 3: Create a new PDF with the generated content
    create_pdf(new_content, tables, output_pdf)


# Example usage:
bucket_name = 'your-bucket-name'  # Replace with your S3 bucket name
document_name = 'your-pdf-file.pdf'  # Replace with the name of the PDF file in S3
output_pdf = 'path_to_output_pdf.pdf'  # Replace with the path where you want to save the new PDF

# Call the function to process the PDF from S3 and generate a new version
process_pdf_from_s3(bucket_name, document_name, output_pdf)

